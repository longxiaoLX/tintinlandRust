# 小结

下面对所有权、不可变引用、可变引用三者的规则和特性进行小结。

## 所有权

值也可以叫资源，所有权就是对资源拥有的权利。

### 类型存储在内存的位置

- 栈上（栈帧）：对于固定字节数的类型，会默认存放在栈上（栈帧中），例如`u32`
- 堆上：不固定字节数的类型，会默认建在堆上（成为堆上的一个资源），然后在栈上用一个局部变量来指向它，例如`String`

### 规则

1. Rust 中，每一个值（资源）都有一个所有者。所有者，在代码中，就表示为变量，也就是说所有者会用变量名来表示。
2. 任何一个时刻，一个值只有一个所有者
3. 当所有者所在作用域结束的时候，值会被释放掉。作用域简单来说，就是从变量创建时开始，到花括号结束的地方。

### 特性

- move 移动：做移动（所有权）操作。**其他类型，默认都是做值的移动操作**。
- copy 复制：通过复制产生新的资源及所有权，默认做复制操作有：
  - 所有的整数类型：比如`u32`
  - 布尔类型，`bool`
  - 浮点数类型：`f32`，`f64`
  - 字符类型：`char`
  - 由以上类型组成的元组类型`Tuple`，如`(i32,i32,char)`

## 借用和引用

背景：对于 move 的类型的变量，如果在调用完函数后，还需要继续使用这个变量，根据以上的知识，需要将传入值的所有权，转移出来，这是一个相当麻烦的过程。由此，提出借用和引用的概念。

- 引用：使用`&`符号，允许使用值但不获取其所有权
- 借用：创建一个引用的行为成为借用

引用也是一种值，并且是固定长度的值。因为其是固定长度，在赋值给其他变量的时候，做的是 copy 操作。

```rust
let a = 10u32;
let b = &a;
println!("{a}");
println!("{b}");

// 输出结果：
// 10
// 10
```

上面的代码例子说明：Rust 关注最终值的部分，而不是中间的内存地址。

### 不可变引用、可变引用

背景：单需要对引用的值进行修改的时候，根据以上的知识，只有获得所有权才能进行修改，但是这种所有权传来传去比较麻烦，而且有些库不会交出所有权。因此需要加入可变引用的概念。

- 引用包含不可变引用和可变引用
- `&x`对变量` x `的不可变引用
- `&mut x`对变量 `x` 的可变引用

#### 特性

- 引用的作用域是从它定义到它最后一次使用时结束。如果它定义了，但并没有被使用，那它的作用域就只有它定义的那一行，即，出生即死亡。
- 不可变引用可以被 copy
- 可变引用不能被 copy，只能被move
- 一个函数的参数接受的是可变引用，或所有权参数，那么它里面的逻辑一般都会对引用的资源进行修改
- 如果一个函数参数只接受不可变引用，那么它里面的逻辑，就一定不会修改被引用的资源

### 规则

- 引用（不可变引用和可变引用都是）变量的作用域不会长于所有权变量的作用域。肯定的，不然就会出现悬锤引用了，这是典型的内存安全问题。 Rust 中的引用必定是有效的；
- 一个资源的可变引用与不可变引用的作用域不能交叠（overlap ），也可以说不能同时存在；
- 某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在；
- 一个资源的不可变引用，可以同时存在多个；